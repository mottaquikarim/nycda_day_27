{"home":{"content":"# Intro to ExpressJS\n---\n\nWelcome to **Lecture 27**! Here is a brief class breakdown.\n\n## Learning Objectives\n1. Complete our end-to-end todo list app\n2. Understand how Express JS works\n\n## To Do Today\n\n### [Warmup](#warmup)\n### [Express](#express)","idx":0},"title":{"content":"Intro to ExpressJS","idx":1},"desc":{"content":"Headfirst intro to ExpressJS","idx":2},"warmup":{"content":"# Warmup\n---\n\nLet's begin with a few short exercises.\n\n## Exercise 1\n\n**REQUIRED**\n\nGit clone our repo: **[NYCDA_todolist](https://github.com/mottaquikarim/NYCDA_todolist)**.\n\nTo do this, you must:\n\n1. Open up that link above and copy the URL\n2. In terminal, do the following\n\n```bash\n$ git clone [url_link]\n```\n\nThen, install all necessary dependencies:\n\n```bash\n$ cd NYCDA_todolist\n$ npm install\n```\n\n**Question**: what's the purpose of this again?\n\nFinally, run the server:\n\n```\n$ npm start\n```\n\n## Exercise 2\n\n**REQUIRED**\n\nNow, let's go ahead and implement the **DELETE** method to complete our app.\n\n\nWe want to make a request along the lines of:\n\n**DELETE /api/todo/:id**\n\nThe **:id** represents **parameterized routing**. Basically, we want one or more of our route path items to be a variable that can be piped in. \n\nImplement this feature on both the **serverside** and the **clientside**.\n\n**HINT**: almost exactly the same as the **PUT** request we implemented.\n\n","idx":3},"express":{"content":"# Express\n---\n\nAnd now to Express.\n\n## What is Express?\n\nThink of Express as a lightweight wrapper around the **http** object we have been using so far.\n\nIt's helpful because it allows us to organize our serverside routing / route handling functionality. Plus, it supports an ecosystem of plugins that help us handle common serverside tasks easily (ie: like authentication).\n\n## Installing Express\n\nFairly standard by now:\n\n```bash\n$ npm install --save express\n```\n\n## Simple Example\n\n```js\n//include express\nconst express = require('express');\n//create an express application\nconst app = express();\n\n//define a route on `/hello/world`\napp.get('/hello/world',(request, response) => {\n    console.log('got request for \"/hello/world\"');\n    response.send('hello there!');\n});\n\n//have the application listen on a specific port\napp.listen(3000, () => {\n    console.log('Example app listening on port 3000!');\n});\n```\n\nSimilar to our **http** code, right?\n\n## Order of Operations\n\nIn express, order of route definitions matter. Consider the following:\n\n```js\napp.get('/hello', function(request, response) { ... });\n//if no routes are matched, return a 404\napp.get('*', function(request, response) {\n    request.status(404).send('uh oh! page not found!');\n});\n```\n\nAnother example:\n\n```js\napp.get('/hello/:name', function(request, response) { ... });\napp.get('/hello/world', function(request, response) { ... });\n```\n\n**Question**: How could we get around this?\n\n## Parameterized Routes\n\n```js\n//include express\nconst express = require('express');\n//create an express application\nconst app = express();\n\n//define a route to greet someone by name, eg /hello/sally\napp.get('/hello/:name', (request, response) => {\n    console.log(`got request for \"/hello/${request.params.name}\"`);\n    //in the above example, returns \"hello sally!\"\n    response.send(`hello ${request.params.name}!`);\n});\n\n//have the application listen on a specific port\napp.listen(3000, () => {\n    console.log('Example app listening on port 3000!');\n});\n```\n\n## Middleware\n\nIMO, the secret sauce behind express. Just like **jQuery** has the rich ecosystem of plugins, **express** has a rich ecosystem of **middleware** that allows you to easily build a server system out of smaller pars.\n\nConsider the following:\n\n```js\nconst express = require('express');\n// this is middleware\nconst parser = require('body-parser');\nconst app = express();\n\n//parses requests with the content type of `application/json`\napp.use(parser.json());\n\napp.post('/submit',(request, response) => {\n    //if a json payload is posted to `/submit`,\n    //body-parser's json parser will parse it and\n    //attach it as `request.body`.\n    console.log(request.body);\n    response.send('request received.');\n});\n```\n\n**Questions**:\n\n1. What is the code above doing?\n2. Why is it useful?\n3. What makes something \"middleware\"?\n\n### Generic Middleware\nHere's a more raw example of middleware\n```js\n//middleware handlers look very similar to route handlers\napp.use((request, response, next) => {\n    //if we wanted to forbid query string usage,\n    //that could be done in middleware.\n    if(Object.keys(request.query).length > 0) {\n        response.status(400).send(\"You can't use query strings!\");\n    } else {\n        next();\n    }\n});\n```\n\nOther examples of middleware:\n1. **serve-static**: npm module that handles serving static files, much like we configured **/public** to always be server. **[Install](https://github.com/expressjs/serve-static)**\n2. **cookie-parser**: parses cookies for back and forth communication - we'll talk about this eventually.\n\n**[Documentation](http://expressjs.com/en/guide/using-middleware.html)** here.\n\n## Composing in Express\n\nYou have the ability to structure your express app in multiple ways.\n\n### Express.Router()\n\nAllows your to define your routes independently of any sort of app instance. Super useful for breaking out different parts of a larger project. \n\n**[Great explanation](http://stackoverflow.com/a/33261362)** of **Express.Router()** in action.\n\n### App.use()\n\nAllows you to create multiple **different** express apps and then **compose** them into one new app. Watch.\n\n**static-serve.js**\n```js\nconst express = require('express');\nconst serveStatic = require('serve-static');\nconst app = express();\n\napp.use('/', serveStatic( 'public', {'index': [ 'index.html' ]}))\n\n// set up static file serve\nmodule.exports = app;\n```\n\n**index.js**\n```js\n//include express\nconst express = require('express');\n//create a *new* express application\nconst app = express();\n// pull in our static app\nconst staticapp = require('./static-serve');\n\n//define a route on `/hello/world`\napp.get('/hello/world',(request, response) => {\n    response.send('hello there!');\n});\n\n// COMPOSE staticapp with new app\napp.use( staticapp )\n\n//have the application listen on a specific port\napp.listen(3000, () => {\n    console.log('Example app listening on port 3000!');\n});\n```\n\n## Exercise\n\nRebuild the entire todo list app, but this time using Express, body-parser, and any other middleware of your choosing.\n","idx":4},"__list__":["home","title","desc","warmup","express"]}